/**
 * @fileOverview Hash Array Mapped Trie.
 * 
 * This code is based on: https://github.com/exclipy/pdata
 */
package(
    hash
    
    make
    
// Mutation
    beginMutation
    endMutation
    mutate
    
// Queries
    tryGet
    get
    has
    
// Single Update
    set
    modify
    remove
    
// Aggregate
    fold
    count
    pairs
    keys
    values)
{

var constant := \x -> \ -> x;

/* Configuration
 ******************************************************************************/
var SIZE := 5;

var BUCKET_SIZE := Math.pow(2, SIZE);

var mask := BUCKET_SIZE - 1;

var MAX_INDEX_NODE := BUCKET_SIZE / 2;

var MIN_ARRAY_NODE := BUCKET_SIZE / 4;

var EDIT_NONE := 0;

/* Nothing
 ******************************************************************************/
var nothing := ({});

var isNothing := (=== nothing);

var maybe := \val def ->
    ?isNothing val
        :def
        :val;

/* Bit Ops
 ******************************************************************************/
/**
 * Hamming weight.
 * 
 * Taken from: http://jsperf.com/hamming-weight
 */
var popcount = let
    m1 = 0x55555555,
    m2 = 0x33333333,
    m4 = 0x0f0f0f0f
in
    \x -> let
        x = x - ((x >> 1) & m1),
        x = (x & m2) + ((x >> 2) & m2),
        x = (x + (x >> 4)) & m4,
        x = x + (x >> 8),
        x = x + (x >> 16)
    in
        (x & 0x7f);

var hashFragment := \shift h ->
    (h >>> shift) & mask;

var toBitmap := (<<, 1);

var fromBitmap := \bitmap bit ->
    popcount(bitmap & (bit - 1));

/* Array Ops
 ******************************************************************************/
var copy := \arr -> arr.slice();

/**
 * Set a value in an array.
 * 
 * @param mutate Should `arr` be mutated?
 * @param at Index to change.
 * @param v New value
 * @param arr Array.
 */
var arrayUpdate := \mutate at v arr -> {
    var out := ?mutate : arr : copy arr;
    out.(at) = v;
    return out;
};

/**
 * Remove a value from an array .
 * 
 * @param mutate Should `arr` be mutated?
 * @param at Index to remove.
 * @param arr Array.
 */
var arraySpliceOut := \mutate at arr -> {
    var out := ?mutate : arr : copy arr;
    out.splice(at, 1);
    return out;
};

/**
 * Insert a value into an array.
 * 
 * @param mutate Should `arr` be mutated?
 * @param at Index to insert at.
 * @param v Value to insert,
 * @param arr Array.
 */
var arraySpliceIn := \mutate at v arr -> {
    var out := ?mutate : arr : copy arr;
    out.splice(at, 0, v);
    return out;
};

/**
 * Append a value into array.
 * 
 * @param mutate Should `arr` be mutated?
 * @param v Value.
 * @param arr Array.
 */
var arrayPush := \mutate v arr ->
    arrayUpdate(
        mutate,
        arr.length,
        v,
        arr);

/*
 ******************************************************************************/
/**
 * Get 32 bit hash of string.
 * 
 * Based on:
 * http://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript-jquery
 */
hash := \str -> {
    if (typeof str === 'number')
        return str;
    
    var hash = 0;
    for (var i = 0, len = str.length; i < len; i = i + 1)
    with c = str.charCodeAt(i) in {
        hash = (((hash << 5) - hash) + c) | 0;
    }
    return hash;
};

/* Node Structures
 ******************************************************************************/
/**
 * Empty node.
 */
var empty := null;

/**
 * Leaf holding a value.
 * 
 * @member edit 
 * @member hash Hash of key.
 * @member key Key.
 * @member value Value stored.
 */
var Leaf := function \edit hash key value =self-> {
    self.edit = edit;
    self.hash = hash;
    self.key = key;
    self.value = value;
};

/**
 * Leaf holding multiple values with the same hash but different keys.
 * 
 * @member edit 
 * @member hash Hash of key.
 * @member children Array of collision children node.
 */
var Collision := function \edit hash children =self-> {
    self.hash = hash;
    self.children = children;
};

/**
 * Internal node with a sparse set of children.
 * 
 * Uses a bitmap and array to pack children.
 * 
 * @member edit
 * @member mask Bitmap that encode the positions of children in the array.
 * @member children Array of child nodes.
 */
var IndexedNode := function \edit mask children =self-> {
    self.edit = edit;
    self.mask = mask;
    self.children = children;
};

/**
 * Internal node with many children.
 * 
 * @member edit
 * @member count Number of children.
 * @member children Array of child nodes.
 */
var ArrayNode := function \edit count children =self-> {
    self.edit = edit;
    self.count = count;
    self.children = children;
};

/* 
 ******************************************************************************/
var isEmpty := (!);

/**
 * Can a node be edited by `edit`?
 */
var canEdit := \edit node ->
    edit === node.edit;

/**
 * Is `node` a leaf node?
 */
var isLeaf = \node ->
    (  node === empty
    || node instanceof Leaf
    || node instanceof Collision);

/**
 * Expand an indexed node into an array node.
 * 
 * @param frag Index of added child.
 * @param child Added child.
 * @param mask Index node mask before child added.
 * @param subNodes Index node children before child added.
 */
var expand = \edit frag child bitmap subNodes -> {
    var bit = bitmap;
    var arr = [], count = 0;
    for (var i = 0; bit; i = i + 1) {
        if (bit & 1) {
            arr.(i) = subNodes.(count);
            count = count + 1;
        }
        bit = bit >>> 1;
    }
    arr.(frag) = child;
    return new ArrayNode(edit, count + 1, arr);
};

/**
 * Collapse an array node into a indexed node.
 */
var pack = \edit removed elements -> {
    var children = [],
        bitmap = 0;
    
    for (var i = 0, len = elements.length; i < len; i = i + 1)
    with elem = elements.(i) in {
        if (i !== removed && !isEmpty elem) {
            children.push(elem);
            bitmap = bitmap | (1 << i);
        }
    }
    return new IndexedNode(edit, bitmap, children);
};

/**
 * Merge two leaf nodes.
 * 
 * @param shift Current shift.
 * @param n1 Node.
 * @param n2 Node.
 */
var mergeLeaves = \edit shift n1 n2 -> let
    h1 = n1.hash,
    h2 = n2.hash
in
    ?h1 === h2
        :new Collision(edit, h1, [n2, n1])
        :let
            subH1 = hashFragment(shift, h1),
            subH2 = hashFragment(shift, h2)
        in
            new IndexedNode(
                edit,
                toBitmap subH1 | toBitmap subH2,
                ?subH1 === subH2
                    :[mergeLeaves(edit, shift + SIZE, n1, n2)]
                    :?subH1 < subH2 : [n1, n2] : [n2, n1]);

/**
 * Update an entry in a collision list.
 */
var modifyCollisionList = \mutate eq list f k -> {
    for (var i = 0, len = list.length; i < len; i = i + 1)
    with child = list.(i) in {
        if (eq(child.key, k))
        with v = f(child.value) in {
            return ?isNothing v
                :arraySpliceOut(mutate, i, list)
                :arrayUpdate(mutate, i, v, list);
        }
    }
    
    // no matching collision child found
    with v = f() in {
        return ?isNothing v
            :list
            :arrayPush(mutate, v, list);
    }
};

/* Definition
 ******************************************************************************/
var Tree := function \mutable edit config root =self-> {
    self.mutable = mutable;
    self.edit = edit;
    self.config = config;
    self.root = root;
};

Tree.setRoot := \root tree -> {
    if (tree.mutable) {
        tree.root = root;
        return tree;
    }
    return new Tree(
        tree.mutable,
        tree.edit,
        tree.config,
        root);
};

/**
 * Create a new HAMT.
 * 
 * @param config#{hash, keyEq} Optional configuration of how the HAMT operates.
 */
make := let
    defKeyCompare = (===)
in
    \config ->
        new Tree(
            false,
            EDIT_NONE, {
                keyEq: (config && config.keyEq) || defKeyCompare,
                hash: (config && config.hash) || hash
            },
            empty);

/* Mutation
 * 
 * Mutation in HAMT uses transaction style interface. Between calls to `beginMutation`
 * and `endMuation` the tree structure and internal nodes may be modified freely.
 * However, these modifications will not effect any immutable copies captured
 * before the call to `beginMutation` or any operations after `endMuation`.
 * 
 * Mutation block allow mutation only for operations performed in that block. You
 * should generally not store the tree while it is in a mutable state.
 ******************************************************************************/
/**
 * Low level operation that marks a HAMT as mutable.
 * 
 * @param tree HAMT
 */
beginMutation := \tree ->
    new Tree(
        true,
        tree.edit + 1,
        tree.config,
        tree.root);

/**
 * Low level operation that marks a HAMT as immutable.
 * 
 * @param tree HAMT
 */
endMutation := \tree ->
     new Tree(
        false,
        tree.edit,
        tree.config,
        tree.root);

/**
 * Perform operations in `f` on a mutable version of `m`.
 * 
 * `f` is a function that is passed a reference to the mutable copy of `m`.
 * Once `f` returns, the mutable copy of `m` is locked again.
 * 
 * @param f Function taking mutable HAMT that performs operations on it.
 * @param m HAMT.
 * 
 */
mutate := \f m -> {
    var t = beginMutation(m);
    f(t);
    return endMutation(t);
};

/* Lookups
 ******************************************************************************/
var lookup;

/**
 * Leaf::get
 */
Leaf.prototype.lookup = \eq _ _ k =self->
    ?eq(self.key, k)
        :self.value
        :nothing;

/**
 * Collision::get
 */
Collision.prototype.lookup = \eq _ h k =self-> {
    if (h === self.hash) {
        for (var i = 0, len = self.children.length; i < len; i = i + 1)
        with child = self.children.(i) in {
            if (eq(child.key, k))
                return child.value;
        }
    }
    return nothing;
};

/**
 * IndexedNode::get
 */
IndexedNode.prototype.lookup = \eq shift h k =self-> let
    frag = hashFragment(shift, h),
    bit = toBitmap frag
in
    ?self.mask & bit
        :lookup(eq, self.children.(fromBitmap(self.mask, bit)), shift + SIZE, h, k)
        :nothing;

/**
 * ArrayNode::get
 */
ArrayNode.prototype.lookup = \eq shift h k =self-> let
    frag = hashFragment(shift, h),
    child = self.children.(frag)
in
    lookup(eq, child, shift + SIZE, h, k);

lookup := \eq n shift h k ->
    ?isEmpty n
        :nothing
        :n.lookup(eq, shift, h, k);

/* Editing
 ******************************************************************************/
var alter;

/**
 * Leaf::modify
 */
Leaf.prototype.modify := \mutate eq edit shift f h k =self-> {
    if (eq(self.key, k)) {
        var v := f(self.value);
        if (isNothing v)
            return empty;
        
        if (canEdit(edit, self)) {
            self.value = v;
            return self;
        } else {
            return new Leaf(edit, h, k, v);
        }
    }
    
    return let v := f() in
        ?isNothing v
            :self
            :mergeLeaves(edit, shift, self, new Leaf(edit, h, k, v));
};

/**
 * Collision::modify
 */
Collision.prototype.modify = \mutate eq edit shift f h k =self-> {
    var list := modifyCollisionList(
        mutate && canEdit(edit, self),
        eq,
        self.children,
        f,
        k);
    
    if (list.length <= 1)
        return list.(0);
    
    return ?mutate && canEdit(edit, self)
        :self
        :new Collision(edit, h, list);
};

var updateIndexedNode := \mutate node edit bitmap children -> {
    if (mutate) {
        node.mask = bitmap;
        node.children = children;
        return node;
    } else {
        return new IndexedNode(edit, bitmap, children);
    }
};

/**
 * IndexedNode::modify
 */
IndexedNode.prototype.modify := \mutate eq edit shift f h k =self#{children}-> {
    var e = mutate && canEdit(edit, self);
    var frag := hashFragment(shift, h),
        bit := toBitmap frag,
        indx := fromBitmap(self.mask, bit),
        exists := self.mask & bit,
        
        child := alter(e, eq, edit, ?exists : children.(indx) : empty, shift + SIZE, f, h, k),
        
        removed := exists && isEmpty child,
        added := !exists && !isEmpty child,
        
        bitmap := ?removed
            :self.mask & ~bit
            :?added
                :self.mask | bit
                :self.mask;
    
    if (!bitmap) {
        return empty;
    } else if (removed) {
        if (children.length <= 2 && isLeaf children.(indx ^ 1)) {
            // collapse
            return children.(indx ^ 1);
        }
        return updateIndexedNode(
            e,
            self,
            edit,
            bitmap,
            arraySpliceOut(e, indx, self.children));
    } else if (added) {
        if (self.children.length >= MAX_INDEX_NODE)
            return expand(edit, frag, child, self.mask, children);
        
        return updateIndexedNode(
            e,
            self,
            edit,
            bitmap,
            arraySpliceIn(e, indx, child, self.children));
    } else { // modify
        return updateIndexedNode(
            e,
            self,
            edit,
            bitmap,
            arrayUpdate(e, indx, child, self.children));
    }
};

var updateArrayNode := \mutate node edit count children -> {
    if (mutate) {
        node.count = count;
        node.children = children;
        return node;
    } else {
        return new ArrayNode(edit, count, children);
    }
};

/**
 * ArrayNode::modify
 */
ArrayNode.prototype.modify = \mutate eq edit shift f h k =self-> {
    var e = mutate && canEdit(edit, self);
    
    var frag := hashFragment(shift, h),
        child = self.children.(frag),
        newChild = alter(e, eq, edit, child, shift + SIZE, f, h, k);
    
    if (isEmpty child && !isEmpty newChild) {
        // add
        return updateArrayNode(
            e,
            self,
            edit,
            self.count + 1,
            arrayUpdate(e, frag, newChild, self.children));
    } else if (!isEmpty child && isEmpty newChild) {
        // remove
        if (self.count - 1 <= MIN_ARRAY_NODE)
            return pack(edit, frag, self.children);
        return updateArrayNode(
            e,
            self,
            edit,
            self.count - 1,
            arrayUpdate(e, frag, empty, self.children));
    } else {
        // modify
       return updateArrayNode(
            e,
            self,
            edit,
            self.count,
            arrayUpdate(e, frag, newChild, self.children));
    }
};

alter := \mutate eq edit n shift f h k ->
    ?isEmpty n
        :let v = f() in
            ?isNothing v
                :empty
                :new Leaf(edit, h, k, v)
    :n.modify(
        mutate,
        eq,
        ?mutate : edit : EDIT_NONE,
        shift,
        f,
        h,
        k);

/* Queries
 ******************************************************************************/
/**
 * Try looking up the value stored for `k`.
 * 
 * @param alt Fallback value returned if no such key exists.
 * @param k Key.
 * @param m HAMT.
 */
tryGet := \alt k m ->
    maybe(
        lookup(
            m.config.keyEq,
            m.root,
            0,
            m.config.hash k,
            k),
        alt);

/**
 * Lookup the value stored for `k`.
 * 
 * Return null if none.
 * 
 * @param k Key.
 * @param m HAMT.
 */
get := tryGet @ null;

/**
 * Does an entry for `k` exist?
 * 
 * @param k Key.
 * @param m HAMT.
 */
has := \k m ->
    !isNothing tryGet(nothing, k, m);

/* Single Updates
 ******************************************************************************/
/**
 * Alter a value already stored in the map.
 * 
 * @param k Key.
 * @param f Function mapping current value to new value.
 * @param m HAMT
 */
modify := \k f m ->
    Tree.setRoot(
        alter(
            m.mutable,
            m.config.keyEq,
            m.edit,
            m.root,
            0,
            f,
            m.config.hash k,
            k),
        m);

/**
 * Store a value in the map.
 * 
 * @param k Key.
 * @param v Value to store.
 * @param m HAMT
 */
set := \k v m ->
    modify(k, constant v, m);

/**
 * Remove a value from the map.
 * 
 * @param k Key.
 * @param m HAMT
 */
remove := let del = constant nothing in
    \k m ->
        modify(k, del, m);

/* Fold
 ******************************************************************************/
/**
 * Leaf::fold
 */
Leaf.prototype.fold := \f z =self->
    f(z, self);

/**
 * Collision::fold
 */
Collision.prototype.fold := \f z ={children}->
    children.reduce(f, z);

/**
 * IndexedNode::fold, ArrayNode::fold
 * 
 * `self.children.reduce(fold@f, z)`
 */
IndexedNode.prototype.fold := ArrayNode.prototype.fold := \f z ={children}-> {
    var z1 = z;
    for (var i = 0, len = children.length; i < len; i = i + 1)
    with c = children.(i) in {
        if (c)
            z1 = ?c instanceof Leaf
                :f(z1, c)
                :c.fold(f, z1);
    } 
    return z1;
};

/**
 * Visit every entry in the map, aggregating data.
 * 
 * Order of nodes is not guaranteed.
 * 
 * @param f Function mapping previous value and key value object to new value.
 * @param z Starting value.
 * @param m Hashtrie
 */
fold := \f z {root} ->
    ?isEmpty root
        :z
        :root.fold(f, z);

/* Aggregate
 ******************************************************************************/
/**
 * Get the number of entries.
 */
count = fold @ (+ 1) @ 0;

/**
 * Get array of all key value pairs as arrays of [key, value].
 * 
 * Order is not guaranteed.
 */
pairs = let build = \p {key value} -> { p.push [key, value]; return p; } in
    \m ->
        fold(build, [], m);

/**
 * Get array of all keys.
 * 
 * Order is not guaranteed.
 */
keys = let build = \p {key} -> { p.push key; return p; } in
    \m ->
        fold(build, [], m);

/**
 * Get array of all values.
 * 
 * Order is not guaranteed, duplicates will be preserved.
 */
values = let build = \p {value} -> { p.push value; return p; } in
    \m ->
        fold(build, [], m);

}